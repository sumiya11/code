define void @julia__mul_var_quo_UInt32_13489({ i8, {}* }* noalias nocapture noundef nonnull sret({ i8, {}* }) align 8 dereferenceable(16) %0, [1 x {}*]* noalias nocapture noundef nonnull align 8 dereferenceable(8) %1, {}* noundef nonnull align 16 dereferenceable(40) %2, i32 signext %3, {}* noundef nonnull align 16 dereferenceable(40) %4, {}* noundef nonnull align 16 dereferenceable(40) %5, i32 zeroext %6, { i64, i8, i64, i8 }* nocapture noundef nonnull readonly align 8 dereferenceable(32) %7) #0 {
top:
  %gcframe141 = alloca [6 x {}*], align 16
  %gcframe141.sub = getelementptr inbounds [6 x {}*], [6 x {}*]* %gcframe141, i64 0, i64 0
  %8 = bitcast [6 x {}*]* %gcframe141 to i8*
  call void @llvm.memset.p0i8.i32(i8* noundef nonnull align 16 dereferenceable(48) %8, i8 0, i32 48, i1 false)
  %9 = getelementptr inbounds [6 x {}*], [6 x {}*]* %gcframe141, i64 0, i64 2
  %thread_ptr = call i8* asm "movq %fs:0, $0", "=r"() #11
  %ppgcstack_i8 = getelementptr i8, i8* %thread_ptr, i64 -8
  %ppgcstack = bitcast i8* %ppgcstack_i8 to {}****
  %pgcstack = load {}***, {}**** %ppgcstack, align 8
  %10 = bitcast [6 x {}*]* %gcframe141 to i64*
  store i64 16, i64* %10, align 16
  %11 = getelementptr inbounds [6 x {}*], [6 x {}*]* %gcframe141, i64 0, i64 1
  %12 = bitcast {}** %11 to {}***
  %13 = load {}**, {}*** %pgcstack, align 8
  store {}** %13, {}*** %12, align 8
  %14 = bitcast {}*** %pgcstack to {}***
  store {}** %gcframe141.sub, {}*** %14, align 8
  %15 = bitcast {}* %2 to { i8*, i64, i16, i16, i32 }*
  %16 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %15, i64 0, i32 1
  %17 = load i64, i64* %16, align 8
  %18 = zext i32 %6 to i64
  %19 = add nsw i64 %18, -1
  %20 = sitofp i64 %19 to double
  %21 = call double @j__log_13491(double %20, {}* inttoptr (i64 139663579224176 to {}*)) #0
  %22 = fmul double %21, 2.000000e+00
  %23 = fdiv double %22, 0x3FE62E42FEFA39EF
  %24 = fsub double 6.300000e+01, %23
  %25 = call double @llvm.floor.f64(double %24)
  %26 = call double @"j_^_13492"(double 2.000000e+00, double %25) #0
  %27 = fcmp ult double %26, 0xC1E0000000000000
  %28 = fcmp ugt double %26, 0x41DFFFFFFFC00000
  %29 = or i1 %27, %28
  %30 = call double @llvm.trunc.f64(double %26)
  %31 = fcmp une double %30, %26
  %or.cond = select i1 %29, i1 true, i1 %31
  br i1 %or.cond, label %L23, label %L21

L21:                                              ; preds = %top
  %32 = fptosi double %26 to i32
  %33 = freeze i32 %32
  %34 = call nonnull {}* inttoptr (i64 139663677433280 to {}* ({}*, i64)*)({}* inttoptr (i64 139663435712336 to {}*), i64 %17)
  %35 = bitcast {}* %34 to { i8*, i64, i16, i16, i32 }*
  %36 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %35, i64 0, i32 1
  %37 = load i64, i64* %36, align 8
  %.not.not = icmp eq i64 %37, 0
  br i1 %.not.not, label %L56, label %L39.preheader

L39.preheader:                                    ; preds = %L21
  %38 = bitcast {}* %34 to i8**
  %39 = load i8*, i8** %38, align 8
  %40 = shl nuw i64 %37, 3
  call void @llvm.memset.p0i8.i64(i8* nonnull align 8 %39, i8 0, i64 %40, i1 false)
  br label %L56

L23:                                              ; preds = %top
  %41 = bitcast {}** %9 to [3 x {}*]*
  %ptls_field142 = getelementptr inbounds {}**, {}*** %pgcstack, i64 2
  %42 = bitcast {}*** %ptls_field142 to i8**
  %ptls_load143144 = load i8*, i8** %42, align 8
  %43 = call noalias nonnull {}* @ijl_gc_pool_alloc(i8* %ptls_load143144, i32 1392, i32 16) #1
  %44 = bitcast {}* %43 to i64*
  %45 = getelementptr inbounds i64, i64* %44, i64 -1
  store atomic i64 139663435709808, i64* %45 unordered, align 8
  %46 = bitcast {}* %43 to double*
  store double %26, double* %46, align 8
  %47 = getelementptr inbounds [6 x {}*], [6 x {}*]* %gcframe141, i64 0, i64 5
  store {}* %43, {}** %47, align 8
  call void @j_InexactError_13497([3 x {}*]* noalias nocapture noundef nonnull sret([3 x {}*]) %41, {}* inttoptr (i64 139663578904240 to {}*), {}* readonly inttoptr (i64 139663435712160 to {}*), {}* nonnull readonly %43) #0
  %ptls_load139145146 = load i8*, i8** %42, align 8
  %48 = call noalias nonnull {}* @ijl_gc_pool_alloc(i8* %ptls_load139145146, i32 1440, i32 32) #1
  %49 = bitcast {}* %48 to i64*
  %50 = getelementptr inbounds i64, i64* %49, i64 -1
  store atomic i64 139663350968928, i64* %50 unordered, align 8
  %51 = bitcast {}* %48 to i8*
  %52 = bitcast {}** %9 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(24) %51, i8* noundef nonnull align 16 dereferenceable(24) %52, i64 24, i1 false)
  call void @ijl_throw({}* %48)
  unreachable

L56:                                              ; preds = %L39.preheader, %L21
  %.not.not52 = icmp eq i64 %17, 0
  br i1 %.not.not52, label %L249, label %L72.preheader

L72.preheader:                                    ; preds = %L56
  %53 = bitcast {}* %2 to i32**
  %54 = load i32*, i32** %53, align 8
  %55 = sext i32 %3 to i64
  %56 = add nsw i64 %55, -1
  %57 = bitcast {}* %5 to {}***
  %58 = load {}**, {}*** %57, align 8
  %59 = getelementptr inbounds {}*, {}** %58, i64 %56
  %60 = bitcast {}* %4 to {}***
  %61 = load {}**, {}*** %60, align 8
  %62 = bitcast {}* %34 to i64**
  %63 = sext i32 %33 to i64
  %64 = getelementptr inbounds { i64, i8, i64, i8 }, { i64, i8, i64, i8 }* %7, i64 0, i32 0
  %65 = load i64, i64* %64, align 8
  %66 = zext i64 %65 to i128
  %67 = getelementptr inbounds { i64, i8, i64, i8 }, { i64, i8, i64, i8 }* %7, i64 0, i32 3
  %68 = load i8, i8* %67, align 8
  %.not63 = icmp eq i8 %68, 0
  %69 = getelementptr inbounds { i64, i8, i64, i8 }, { i64, i8, i64, i8 }* %7, i64 0, i32 1
  %70 = load i8, i8* %69, align 8
  %71 = icmp ugt i8 %70, 63
  %72 = xor i1 %71, true
  %73 = zext i8 %70 to i64
  %74 = getelementptr inbounds { i64, i8, i64, i8 }, { i64, i8, i64, i8 }* %7, i64 0, i32 2
  %75 = load i64, i64* %74, align 8
  br label %L72

L72:                                              ; preds = %L238, %L72.preheader
  %76 = phi i64 [ %136, %L238 ], [ %37, %L72.preheader ]
  %value_phi13 = phi i64 [ %137, %L238 ], [ 1, %L72.preheader ]
  %77 = add nsw i64 %value_phi13, -1
  %78 = getelementptr inbounds i32, i32* %54, i64 %77
  %79 = load i32, i32* %78, align 4
  %.not = icmp eq i32 %79, 0
  br i1 %.not, label %L238, label %L78

L78:                                              ; preds = %L72
  %80 = load {}*, {}** %59, align 8
  %.not54 = icmp eq {}* %80, null
  br i1 %.not54, label %fail, label %pass

L103:                                             ; preds = %scalar.ph111, %L103
  %value_phi2575 = phi i64 [ %bc.resume.val117, %scalar.ph111 ], [ %88, %L103 ]
  %81 = getelementptr inbounds i64, i64* %157, i64 %value_phi2575
  %82 = load i64, i64* %81, align 8
  %83 = getelementptr inbounds i32, i32* %160, i64 %value_phi2575
  %84 = load i32, i32* %83, align 4
  %85 = zext i32 %84 to i64
  %86 = mul nuw i64 %85, %158
  %87 = add i64 %86, %82
  store i64 %87, i64* %81, align 8
  %88 = add nuw nsw i64 %value_phi2575, 1
  %exitcond.not = icmp eq i64 %88, %76
  br i1 %exitcond.not, label %L126, label %L103

L126:                                             ; preds = %middle.block110, %pass24, %L103
  switch i64 %63, label %after_srem [
    i64 0, label %fail26
    i64 -1, label %L130
  ]

L130:                                             ; preds = %L126
  br i1 %.not.not, label %L238, label %L141.lr.ph

L141.lr.ph:                                       ; preds = %after_srem, %L130
  %89 = load i64*, i64** %62, align 8
  call void @llvm.assume(i1 %72)
  br i1 %.not63, label %L141.lr.ph.split.us, label %L141.lr.ph.L141.lr.ph.split_crit_edge

L141.lr.ph.L141.lr.ph.split_crit_edge:            ; preds = %L141.lr.ph
  br i1 %71, label %L238, label %L141.preheader

L141.preheader:                                   ; preds = %L141.lr.ph.L141.lr.ph.split_crit_edge
  %min.iters.check95 = icmp ult i64 %37, 4
  br i1 %min.iters.check95, label %scalar.ph93, label %vector.ph96

vector.ph96:                                      ; preds = %L141.preheader
  %n.vec98 = and i64 %37, 9223372036854775804
  %broadcast.splatinsert103 = insertelement <4 x i128> poison, i128 %66, i64 0
  %broadcast.splat104 = shufflevector <4 x i128> %broadcast.splatinsert103, <4 x i128> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert105 = insertelement <4 x i64> poison, i64 %73, i64 0
  %broadcast.splat106 = shufflevector <4 x i64> %broadcast.splatinsert105, <4 x i64> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert107 = insertelement <4 x i64> poison, i64 %75, i64 0
  %broadcast.splat108 = shufflevector <4 x i64> %broadcast.splatinsert107, <4 x i64> poison, <4 x i32> zeroinitializer
  br label %vector.body94

vector.body94:                                    ; preds = %vector.body94, %vector.ph96
  %index101 = phi i64 [ 0, %vector.ph96 ], [ %index.next109, %vector.body94 ]
  %90 = getelementptr inbounds i64, i64* %89, i64 %index101
  %91 = bitcast i64* %90 to <4 x i64>*
  %wide.load102 = load <4 x i64>, <4 x i64>* %91, align 8
  %92 = zext <4 x i64> %wide.load102 to <4 x i128>
  %93 = mul nuw <4 x i128> %broadcast.splat104, %92
  %94 = lshr <4 x i128> %93, <i128 64, i128 64, i128 64, i128 64>
  %95 = trunc <4 x i128> %94 to <4 x i64>
  %96 = sub <4 x i64> %wide.load102, %95
  %97 = lshr <4 x i64> %96, <i64 1, i64 1, i64 1, i64 1>
  %98 = add <4 x i64> %97, %95
  %99 = lshr <4 x i64> %98, %broadcast.splat106
  %100 = mul <4 x i64> %99, %broadcast.splat108
  %101 = sub <4 x i64> %wide.load102, %100
  store <4 x i64> %101, <4 x i64>* %91, align 8
  %index.next109 = add nuw i64 %index101, 4
  %102 = icmp eq i64 %index.next109, %n.vec98
  br i1 %102, label %middle.block92, label %vector.body94

middle.block92:                                   ; preds = %vector.body94
  %cmp.n100 = icmp eq i64 %37, %n.vec98
  br i1 %cmp.n100, label %L238, label %scalar.ph93

scalar.ph93:                                      ; preds = %middle.block92, %L141.preheader
  %bc.resume.val99 = phi i64 [ %n.vec98, %middle.block92 ], [ 0, %L141.preheader ]
  br label %L141

L141.lr.ph.split.us:                              ; preds = %L141.lr.ph
  br i1 %71, label %L238, label %L141.us.preheader

L141.us.preheader:                                ; preds = %L141.lr.ph.split.us
  %min.iters.check = icmp ult i64 %37, 4
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %L141.us.preheader
  %n.vec = and i64 %37, 9223372036854775804
  %broadcast.splatinsert = insertelement <4 x i128> poison, i128 %66, i64 0
  %broadcast.splat = shufflevector <4 x i128> %broadcast.splatinsert, <4 x i128> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert88 = insertelement <4 x i64> poison, i64 %73, i64 0
  %broadcast.splat89 = shufflevector <4 x i64> %broadcast.splatinsert88, <4 x i64> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert90 = insertelement <4 x i64> poison, i64 %75, i64 0
  %broadcast.splat91 = shufflevector <4 x i64> %broadcast.splatinsert90, <4 x i64> poison, <4 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %103 = getelementptr inbounds i64, i64* %89, i64 %index
  %104 = bitcast i64* %103 to <4 x i64>*
  %wide.load = load <4 x i64>, <4 x i64>* %104, align 8
  %105 = zext <4 x i64> %wide.load to <4 x i128>
  %106 = mul nuw <4 x i128> %broadcast.splat, %105
  %107 = lshr <4 x i128> %106, <i128 64, i128 64, i128 64, i128 64>
  %108 = trunc <4 x i128> %107 to <4 x i64>
  %109 = lshr <4 x i64> %108, %broadcast.splat89
  %110 = mul <4 x i64> %109, %broadcast.splat91
  %111 = sub <4 x i64> %wide.load, %110
  store <4 x i64> %111, <4 x i64>* %104, align 8
  %index.next = add nuw i64 %index, 4
  %112 = icmp eq i64 %index.next, %n.vec
  br i1 %112, label %middle.block, label %vector.body

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %37, %n.vec
  br i1 %cmp.n, label %L238, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %L141.us.preheader
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %L141.us.preheader ]
  br label %L141.us

L141.us:                                          ; preds = %L141.us, %scalar.ph
  %value_phi2877.us = phi i64 [ %122, %L141.us ], [ %bc.resume.val, %scalar.ph ]
  %113 = getelementptr inbounds i64, i64* %89, i64 %value_phi2877.us
  %114 = load i64, i64* %113, align 8
  %115 = zext i64 %114 to i128
  %116 = mul nuw i128 %66, %115
  %117 = lshr i128 %116, 64
  %118 = trunc i128 %117 to i64
  %119 = lshr i64 %118, %73
  %120 = mul i64 %119, %75
  %121 = sub i64 %114, %120
  store i64 %121, i64* %113, align 8
  %122 = add nuw nsw i64 %value_phi2877.us, 1
  %exitcond82.not = icmp eq i64 %122, %37
  br i1 %exitcond82.not, label %L238, label %L141.us

L141:                                             ; preds = %L141, %scalar.ph93
  %value_phi2877 = phi i64 [ %135, %L141 ], [ %bc.resume.val99, %scalar.ph93 ]
  %123 = getelementptr inbounds i64, i64* %89, i64 %value_phi2877
  %124 = load i64, i64* %123, align 8
  %125 = zext i64 %124 to i128
  %126 = mul nuw i128 %66, %125
  %127 = lshr i128 %126, 64
  %128 = trunc i128 %127 to i64
  %129 = sub i64 %124, %128
  %130 = lshr i64 %129, 1
  %131 = add i64 %130, %128
  %132 = lshr i64 %131, %73
  %133 = mul i64 %132, %75
  %134 = sub i64 %124, %133
  store i64 %134, i64* %123, align 8
  %135 = add nuw nsw i64 %value_phi2877, 1
  %exitcond81.not = icmp eq i64 %135, %37
  br i1 %exitcond81.not, label %L238, label %L141

L238:                                             ; preds = %pass37, %after_srem, %L141, %L141.us, %middle.block, %L141.lr.ph.split.us, %middle.block92, %L141.lr.ph.L141.lr.ph.split_crit_edge, %L130, %L72
  %136 = phi i64 [ %.mux, %after_srem ], [ 0, %L130 ], [ %76, %L72 ], [ %76, %pass37 ], [ %37, %L141.lr.ph.split.us ], [ %37, %L141.us ], [ %37, %middle.block ], [ %37, %L141.lr.ph.L141.lr.ph.split_crit_edge ], [ %37, %L141 ], [ %37, %middle.block92 ]
  %.not53.not = icmp eq i64 %value_phi13, %17
  %137 = add nuw nsw i64 %value_phi13, 1
  br i1 %.not53.not, label %L249, label %L72

L249:                                             ; preds = %pass33, %L238, %L56
  %value_phi18 = phi i8 [ 1, %L56 ], [ 0, %pass33 ], [ 1, %L238 ]
  %138 = getelementptr inbounds [6 x {}*], [6 x {}*]* %gcframe141, i64 0, i64 5
  store {}* %34, {}** %138, align 8
  %139 = call nonnull {}* @j_reduce_mod_13493({}* nonnull %34, i32 zeroext %6, { i64, i8, i64, i8 }* nocapture nonnull readonly %7) #0
  %140 = insertvalue { i8, {}* } zeroinitializer, i8 %value_phi18, 0
  %141 = insertvalue { i8, {}* } %140, {}* %139, 1
  %142 = getelementptr inbounds [1 x {}*], [1 x {}*]* %1, i64 0, i64 0
  store {}* %139, {}** %142, align 8
  store { i8, {}* } %141, { i8, {}* }* %0, align 8
  %143 = load {}*, {}** %11, align 8
  %144 = bitcast {}*** %pgcstack to {}**
  store {}* %143, {}** %144, align 8
  ret void

fail:                                             ; preds = %L78
  call void @ijl_throw({}* inttoptr (i64 139663434559888 to {}*))
  unreachable

pass:                                             ; preds = %L78
  %145 = bitcast {}* %80 to i32**
  %146 = load i32*, i32** %145, align 8
  %147 = getelementptr inbounds i32, i32* %146, i64 %77
  %148 = load i32, i32* %147, align 4
  %149 = sext i32 %148 to i64
  %150 = add nsw i64 %149, -1
  %151 = getelementptr inbounds {}*, {}** %61, i64 %150
  %152 = load {}*, {}** %151, align 8
  %.not55 = icmp eq {}* %152, null
  br i1 %.not55, label %fail19, label %pass20

fail19:                                           ; preds = %pass
  call void @ijl_throw({}* inttoptr (i64 139663434559888 to {}*))
  unreachable

pass20:                                           ; preds = %pass
  %153 = bitcast {}* %152 to { i8*, i64, i16, i16, i32 }*
  %154 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %153, i64 0, i32 1
  %155 = load i64, i64* %154, align 8
  %156 = icmp ult i64 %155, 2
  br i1 %156, label %pass33, label %pass24

pass24:                                           ; preds = %pass20
  %.not58 = icmp eq i64 %76, 0
  br i1 %.not58, label %L126, label %L103.lr.ph

L103.lr.ph:                                       ; preds = %pass24
  %157 = load i64*, i64** %62, align 8
  %158 = zext i32 %79 to i64
  %159 = bitcast {}* %152 to i32**
  %160 = load i32*, i32** %159, align 8
  %min.iters.check113 = icmp ult i64 %76, 16
  br i1 %min.iters.check113, label %scalar.ph111, label %vector.ph114

vector.ph114:                                     ; preds = %L103.lr.ph
  %n.vec116 = and i64 %76, -16
  %broadcast.splatinsert128 = insertelement <4 x i64> poison, i64 %158, i64 0
  %broadcast.splat129 = shufflevector <4 x i64> %broadcast.splatinsert128, <4 x i64> poison, <4 x i32> zeroinitializer
  br label %vector.body112

vector.body112:                                   ; preds = %vector.body112, %vector.ph114
  %index119 = phi i64 [ 0, %vector.ph114 ], [ %index.next136, %vector.body112 ]
  %161 = getelementptr inbounds i64, i64* %157, i64 %index119
  %162 = bitcast i64* %161 to <4 x i64>*
  %wide.load120 = load <4 x i64>, <4 x i64>* %162, align 8
  %163 = getelementptr inbounds i64, i64* %161, i64 4
  %164 = bitcast i64* %163 to <4 x i64>*
  %wide.load121 = load <4 x i64>, <4 x i64>* %164, align 8
  %165 = getelementptr inbounds i64, i64* %161, i64 8
  %166 = bitcast i64* %165 to <4 x i64>*
  %wide.load122 = load <4 x i64>, <4 x i64>* %166, align 8
  %167 = getelementptr inbounds i64, i64* %161, i64 12
  %168 = bitcast i64* %167 to <4 x i64>*
  %wide.load123 = load <4 x i64>, <4 x i64>* %168, align 8
  %169 = getelementptr inbounds i32, i32* %160, i64 %index119
  %170 = bitcast i32* %169 to <4 x i32>*
  %wide.load124 = load <4 x i32>, <4 x i32>* %170, align 4
  %171 = getelementptr inbounds i32, i32* %169, i64 4
  %172 = bitcast i32* %171 to <4 x i32>*
  %wide.load125 = load <4 x i32>, <4 x i32>* %172, align 4
  %173 = getelementptr inbounds i32, i32* %169, i64 8
  %174 = bitcast i32* %173 to <4 x i32>*
  %wide.load126 = load <4 x i32>, <4 x i32>* %174, align 4
  %175 = getelementptr inbounds i32, i32* %169, i64 12
  %176 = bitcast i32* %175 to <4 x i32>*
  %wide.load127 = load <4 x i32>, <4 x i32>* %176, align 4
  %177 = zext <4 x i32> %wide.load124 to <4 x i64>
  %178 = zext <4 x i32> %wide.load125 to <4 x i64>
  %179 = zext <4 x i32> %wide.load126 to <4 x i64>
  %180 = zext <4 x i32> %wide.load127 to <4 x i64>
  %181 = mul nuw <4 x i64> %broadcast.splat129, %177
  %182 = mul nuw <4 x i64> %broadcast.splat129, %178
  %183 = mul nuw <4 x i64> %broadcast.splat129, %179
  %184 = mul nuw <4 x i64> %broadcast.splat129, %180
  %185 = add <4 x i64> %181, %wide.load120
  %186 = add <4 x i64> %182, %wide.load121
  %187 = add <4 x i64> %183, %wide.load122
  %188 = add <4 x i64> %184, %wide.load123
  store <4 x i64> %185, <4 x i64>* %162, align 8
  store <4 x i64> %186, <4 x i64>* %164, align 8
  store <4 x i64> %187, <4 x i64>* %166, align 8
  store <4 x i64> %188, <4 x i64>* %168, align 8
  %index.next136 = add nuw i64 %index119, 16
  %189 = icmp eq i64 %index.next136, %n.vec116
  br i1 %189, label %middle.block110, label %vector.body112

middle.block110:                                  ; preds = %vector.body112
  %cmp.n118 = icmp eq i64 %76, %n.vec116
  br i1 %cmp.n118, label %L126, label %scalar.ph111

scalar.ph111:                                     ; preds = %middle.block110, %L103.lr.ph
  %bc.resume.val117 = phi i64 [ %n.vec116, %middle.block110 ], [ 0, %L103.lr.ph ]
  br label %L103

fail26:                                           ; preds = %L126
  call void @ijl_throw({}* inttoptr (i64 139663434560176 to {}*))
  unreachable

after_srem:                                       ; preds = %L126
  %190 = srem i64 %value_phi13, %63
  %.not60 = icmp ne i64 %190, 0
  %brmerge = select i1 %.not60, i1 true, i1 %.not.not
  %.mux = select i1 %.not60, i64 %76, i64 0
  br i1 %brmerge, label %L238, label %L141.lr.ph

pass33:                                           ; preds = %pass20
  %.not66 = icmp eq i64 %155, 1
  br i1 %.not66, label %pass37, label %L249

pass37:                                           ; preds = %pass33
  %191 = bitcast {}* %152 to i32**
  %192 = load i32*, i32** %191, align 8
  %193 = load i32, i32* %192, align 4
  %194 = zext i32 %193 to i64
  %195 = add nsw i64 %194, -1
  %196 = load i64*, i64** %62, align 8
  %197 = getelementptr inbounds i64, i64* %196, i64 %195
  %198 = load i64, i64* %197, align 8
  %199 = zext i32 %79 to i64
  %200 = add i64 %198, %199
  %201 = zext i64 %200 to i128
  %202 = mul nuw i128 %201, %66
  %203 = lshr i128 %202, 64
  %204 = trunc i128 %203 to i64
  %205 = sub i64 %200, %204
  %206 = lshr i64 %205, 1
  %207 = select i1 %.not63, i64 0, i64 %206
  %208 = add i64 %207, %204
  call void @llvm.assume(i1 %72)
  %209 = lshr i64 %208, %73
  %210 = mul i64 %209, %75
  %211 = sub i64 %200, %210
  store i64 %211, i64* %197, align 8
  br label %L238
}
