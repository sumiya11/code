define void @"julia_add_mul_jam4!_5740"({}* noundef nonnull align 16 dereferenceable(40) %0, i32 zeroext %1, {}* noundef nonnull align 16 dereferenceable(40) %2, i32 zeroext %3, {}* noundef nonnull align 16 dereferenceable(40) %4, i32 zeroext %5, {}* noundef nonnull align 16 dereferenceable(40) %6, i32 zeroext %7, {}* noundef nonnull align 16 dereferenceable(40) %8) #0 {
L26.lr.ph:
  %9 = bitcast {}* %0 to { i8*, i64, i16, i16, i32 }*
  %10 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %9, i64 0, i32 1
  %11 = load i64, i64* %10, align 8
  %.not = icmp ne i64 %11, 0
  call void @llvm.assume(i1 %.not)
  %12 = bitcast {}* %0 to i64**
  %13 = load i64*, i64** %12, align 8
  %14 = zext i32 %1 to i64
  %15 = bitcast {}* %2 to i32**
  %16 = load i32*, i32** %15, align 8
  %17 = zext i32 %3 to i64
  %18 = bitcast {}* %4 to i32**
  %19 = load i32*, i32** %18, align 8
  %20 = zext i32 %5 to i64
  %21 = bitcast {}* %6 to i32**
  %22 = load i32*, i32** %21, align 8
  %23 = zext i32 %7 to i64
  %24 = bitcast {}* %8 to i32**
  %25 = load i32*, i32** %24, align 8
  %min.iters.check = icmp ult i64 %11, 4
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %L26.lr.ph
  %n.vec = and i64 %11, 9223372036854775804
  %broadcast.splatinsert = insertelement <4 x i64> poison, i64 %14, i64 0
  %broadcast.splat = shufflevector <4 x i64> %broadcast.splatinsert, <4 x i64> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert13 = insertelement <4 x i64> poison, i64 %17, i64 0
  %broadcast.splat14 = shufflevector <4 x i64> %broadcast.splatinsert13, <4 x i64> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert16 = insertelement <4 x i64> poison, i64 %20, i64 0
  %broadcast.splat17 = shufflevector <4 x i64> %broadcast.splatinsert16, <4 x i64> poison, <4 x i32> zeroinitializer
  %broadcast.splatinsert19 = insertelement <4 x i64> poison, i64 %23, i64 0
  %broadcast.splat20 = shufflevector <4 x i64> %broadcast.splatinsert19, <4 x i64> poison, <4 x i32> zeroinitializer
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %26 = getelementptr inbounds i64, i64* %13, i64 %index
  %27 = bitcast i64* %26 to <4 x i64>*
  %wide.load = load <4 x i64>, <4 x i64>* %27, align 8
  %28 = getelementptr inbounds i32, i32* %16, i64 %index
  %29 = bitcast i32* %28 to <4 x i32>*
  %wide.load11 = load <4 x i32>, <4 x i32>* %29, align 4
  %30 = zext <4 x i32> %wide.load11 to <4 x i64>
  %31 = mul nuw <4 x i64> %broadcast.splat, %30
  %32 = add <4 x i64> %31, %wide.load
  %33 = getelementptr inbounds i32, i32* %19, i64 %index
  %34 = bitcast i32* %33 to <4 x i32>*
  %wide.load12 = load <4 x i32>, <4 x i32>* %34, align 4
  %35 = zext <4 x i32> %wide.load12 to <4 x i64>
  %36 = mul nuw <4 x i64> %broadcast.splat14, %35
  %37 = add <4 x i64> %32, %36
  %38 = getelementptr inbounds i32, i32* %22, i64 %index
  %39 = bitcast i32* %38 to <4 x i32>*
  %wide.load15 = load <4 x i32>, <4 x i32>* %39, align 4
  %40 = zext <4 x i32> %wide.load15 to <4 x i64>
  %41 = mul nuw <4 x i64> %broadcast.splat17, %40
  %42 = add <4 x i64> %37, %41
  %43 = getelementptr inbounds i32, i32* %25, i64 %index
  %44 = bitcast i32* %43 to <4 x i32>*
  %wide.load18 = load <4 x i32>, <4 x i32>* %44, align 4
  %45 = zext <4 x i32> %wide.load18 to <4 x i64>
  %46 = mul nuw <4 x i64> %broadcast.splat20, %45
  %47 = add <4 x i64> %42, %46
  store <4 x i64> %47, <4 x i64>* %27, align 8
  %index.next = add nuw i64 %index, 4
  %48 = icmp eq i64 %index.next, %n.vec
  br i1 %48, label %middle.block, label %vector.body

middle.block:                                     ; preds = %vector.body
  %cmp.n = icmp eq i64 %11, %n.vec
  br i1 %cmp.n, label %L71, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %L26.lr.ph
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %L26.lr.ph ]
  br label %L26

L26:                                              ; preds = %L26, %scalar.ph
  %value_phi110 = phi i64 [ %bc.resume.val, %scalar.ph ], [ %71, %L26 ]
  %49 = getelementptr inbounds i64, i64* %13, i64 %value_phi110
  %50 = load i64, i64* %49, align 8
  %51 = getelementptr inbounds i32, i32* %16, i64 %value_phi110
  %52 = load i32, i32* %51, align 4
  %53 = zext i32 %52 to i64
  %54 = mul nuw i64 %53, %14
  %55 = add i64 %54, %50
  %56 = getelementptr inbounds i32, i32* %19, i64 %value_phi110
  %57 = load i32, i32* %56, align 4
  %58 = zext i32 %57 to i64
  %59 = mul nuw i64 %58, %17
  %60 = add i64 %55, %59
  %61 = getelementptr inbounds i32, i32* %22, i64 %value_phi110
  %62 = load i32, i32* %61, align 4
  %63 = zext i32 %62 to i64
  %64 = mul nuw i64 %63, %20
  %65 = add i64 %60, %64
  %66 = getelementptr inbounds i32, i32* %25, i64 %value_phi110
  %67 = load i32, i32* %66, align 4
  %68 = zext i32 %67 to i64
  %69 = mul nuw i64 %68, %23
  %70 = add i64 %65, %69
  store i64 %70, i64* %49, align 8
  %71 = add nuw nsw i64 %value_phi110, 1
  %exitcond.not = icmp eq i64 %71, %11
  br i1 %exitcond.not, label %L71, label %L26

L71:                                              ; preds = %L26, %middle.block
  ret void
}
